%/////////////////////////////////////////////////////////////////////////%
%实验5 使用STC编码对空域图像进行自适应隐写嵌入实验
%作者：马赛
%日期：2015.10
%编码版本：MATLAB 7.11.0 (R2010b)
%说明：实验代码被分割为几部分，其中被“%/////%”分割的部分为实验辅助部分，已经完
%         成，请不要进行改动；被“%?????%”分割的部分是实验需要实现的部分，请按照实
%         验要求完成代码的编写。实验编写完成后，运行脚本即可。
%/////////////////////////////////////////////////////////////////////////%

clc;
clear all;
close all;
%%
%/////////////////////////////////////////////////////////////////////////%
%-------------------------------------------------------------------------%
%初始化准备
%
%cover 载体图像矩阵
%stego 载密图像矩阵
%distortion 嵌入失真矩阵
%coverHeight 图像高度
%imageVecLength 像素序列长度
%-------------------------------------------------------------------------%
cover = imread('figure3.bmp');                                 % 载入载体图像
stego = cover;                                                         % 初始化载密图像
distortion = UNIWARD(double(cover));                 % 使用特定的自适应算法生成嵌入失真矩阵

coverHeight = size(cover, 1);
coverWidth  = size(cover, 2);
imageVecLength = coverHeight * coverWidth;     % 计算图像展开成一维像素序列的长度
%/////////////////////////////////////////////////////////////////////////%
%%
%/////////////////////////////////////////////////////////////////////////%
%-------------------------------------------------------------------------%
%将图像展开为向量并置乱
%
%key 控制随机数发生器的种子，这里被用作嵌入密钥
%pixelVecPermuted 置乱后的像素向量
%weightVecPermuted  置乱后的嵌入失真向量，作为STC嵌入的权重
%-------------------------------------------------------------------------%
key = 1000090;                                                                      %隐写置乱使用的密钥（种子），可随意设置，注意不要超过uint32的限定范围
randNumStream = RandStream('mt19937ar','seed',key);             %生成置乱使用的随机数发生器（流）
randNumStream.reset();                                                           %重置随机数发生器，使之随机状态处于序列的开始位置，方便根据密钥控制随机数生成
path = uint32(randperm(randNumStream, imageVecLength));     %根据随机数发生器对像素序列的序号（数组下标）进行随机置乱
randNumStream.reset();                                                           %每次使用随机数发生器后须重置，保证产生的随机数被密钥控制

pixelVec = reshape(cover, 1, imageVecLength);                          %将载体图像按列展开为像素序列
pixelVecPermuted = pixelVec;                                                   %初始化置乱像素序列
weightVec = reshape(distortion, 1, imageVecLength);                 %同样将嵌入失真矩阵展开为序列
weightVecPermuted = weightVec;                                             %初始化置乱嵌入失真序列

for vecIter = 1:imageVecLength
    pixelVecPermuted(vecIter) = pixelVec(path(vecIter));              %按照置乱顺序对像素序列进行重排
    weightVecPermuted(vecIter) = weightVec(path(vecIter));         %按照置乱顺序对嵌入失真序列进行重排
end
%/////////////////////////////////////////////////////////////////////////%
%%
%/////////////////////////////////////////////////////////////////////////%
%-------------------------------------------------------------------------%
%抽取像素的LSB
%
%x 载体像素LSB
%y 载密像素LSB
%-------------------------------------------------------------------------%
x = double(bitand(pixelVecPermuted, ones(size(pixelVecPermuted), 'uint8')));%提取像素序列的LSB
y = x;                                                                                      %初始化修改后的LSB序列
%/////////////////////////////////////////////////////////////////////////%
%%


%?????????????????????????????????????????????????????????????????????????%
%-------------------------------------------------------------------------%
%请在此代码段内实现STC嵌入
%任务：请使用下文提供的用于构造校验矩阵 H 的子矩阵 H_hat ，完成校验矩阵 H 的构造
%         使用Viterbi算法寻找最佳嵌入模式 y。
%提示：1.本代码段可以理解为函数，输入为 x ，输出为 y 。
%         2.使用提供的子函数create_code_from_submatrix()和
%            dual_viterbi()和完成
%         3.请参考提供的例程
%x 载体像素LSB
%y 载密像素LSB
%-------------------------------------------------------------------------%
H_hat= [3 2];
[code,alpha] = create_code_from_submatrix(H_hat, imageVecLength/2);
w = ones(code.n,1);
m = double(rand(sum(code.shift),1)<0.5);
[y,min_cost] = dual_viterbi(code, x, w, m);
x = x';
y = y';
m = [m' ; calc_syndrome(code,y)'];

%%
%/////////////////////////////////////////////////////////////////////////%
%-------------------------------------------------------------------------%
%获得被修改像素的位置
%
%y 记录被修改像素的位置，1为被修改，0为未修改
%-------------------------------------------------------------------------%
y = bitxor(x, y);
%/////////////////////////////////////////////////////////////////////////%
%%
%/////////////////////////////////////////////////////////////////////////%
%-------------------------------------------------------------------------%
%根据嵌入修改的位置对像素进行修改
%-------------------------------------------------------------------------%
for pixelIter = 1:imageVecLength
    if y(pixelIter) == 1
        rowIndex = uint32(mod(path(pixelIter), coverHeight));%提取行位置
        colIndex = uint32(floor(path(pixelIter) / coverHeight));%提取列位置
        if rowIndex == 0                                    %处理行为0的情况
            rowIndex = coverHeight;
        end
        if colIndex == 0                                    %处理列为0的情况
            colIndex = 1;
        end
        stego(rowIndex, colIndex) = ...
            stego(rowIndex, colIndex) - 1;                  %对像素统一进行-1处理
    end
end
%/////////////////////////////////////////////////////////////////////////%
%%
%/////////////////////////////////////////////////////////////////////////%
%-------------------------------------------------------------------------%
%显示实验结果，修改后的图像（左）以及修改位置（右）
%-------------------------------------------------------------------------%
imwrite(stego, 'stego.bmp', 'bmp');
filpped = (double(stego) - double(cover) + 1)/2;
%filpped(filpped ~= 0) = 255;
%filpped = imcomplement(filpped);
imwrite(filpped, 'location.bmp', 'bmp');
subplot(121);
imshow(stego);title('stego image');
subplot(122);
%imshow((double(stego) - double(cover) + 1)/2);
imshow(filpped);title('embed pixel');
%/////////////////////////////////////////////////////////////////////////%